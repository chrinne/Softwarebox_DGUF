---
title: "Daten & SQLite"
author: 
 - Christoph Rinne^[Christian-Albrechts Universität zu Kiel, crinne@ufg.uni-kiel.de]
date: "`r format(Sys.time(), '%d. %B %Y')`"
license: "CC-BY 4.0"
header-includes:
  \renewcommand{\contentsname}{Inhalt}
  \renewcommand{\figurename}{Abb.}
  \renewcommand{\tablename}{Tab.}
output:
  html_document:
    toc: true
    toc_depth: 2
    toc_float: true
    number_sections: true
  pdf_document:
    number_sections: true
    toc: true
    toc_depth: 2
    df_print: kable
fig_caption: true
urlcolor: blue
link-citations: true # make citations hyperlinks
linkcolor: blue
lang: de-DE
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Grundlegende Information

SQL steht für *structured query language* und dient dem Erstellen, Nutzen und Modifizieren von relationalen Datenbanken.  Ob Sie eine SQL-Datenbank verwenden sollten hängt von der Komplexität Ihrer Daten und der geplanten Nutzung ab. Nachfolgend spielen Datenstrukturen und -modelle vorderhand keine Rolle. Sie sollten sich damit aber vor dem Erstellen einer Datenbank befassen.

SQL ist weit verbreitet, Sie finden SQL-Syntax z.B. in QGIS für das Filtern eines Datebestandes. Die grundlegenden Befehle und die zugehörige Syntax sind weitgehend einheitlich, es gibt aber auch zahlreiche Erweiterungen für einzelne Datenbanksysteme (MySQL, PostgreSQL, ORACLE etc). SQL Datenbanksysteme sind fast ausnahmslos Server-Systeme, eine Ausnahme ist [SQLite](https://sqlite.org). 

SQL ist eine Sprache und keine Programm für eine Nutzeroberfläche wie es MS Access oder Libre Office Base bieten.

SQL ist die *lingua franca* für relationale Datenbanken.

## SQLite in R / RStudio

In diesem Skript wird [SQLite](https://sqlite.org) verwendet. Da ich diesen Text in R-Markdown mit RStudio schreibe verwende ich zudem das Paket [RSQLite](https://www.rdocumentation.org/packages/RSQLite), um die Befehle in sogenannten *code-chunks* darstellen und ausführen zu können. Sie können die Befehle aber in jeder anderen Nutzeroberfläche für SQLite ebenfalls ausführen, z.B. dem [DB Browser for SQLite](https://sqlitebrowser.org/) (s.u.).

Sofern noch nicht vorhanden wird mit diesem Code das Paket RSQLite in R installiert und dann geladen.
```{r Install RSQLite if not present, echo=FALSE}
require (RSQLite) || install.packages("RSQLite")
library(RSQLite)
```

Dann wird eine neue SQLite Datenbank im Arbeitsspeicher angelegt und zugleich eine Verbindung "t1db" hergestellt. In einem anderen Programm müssen Sie ebenfalls eine neue Datenbank erstellen die dann auch automatisch geöffnet würde. Um in R auf eine vorhandene Datenbank zuzugreifen müssten Sie 'dbname = "<Dateiname>"' schreiben.

```{r Datenbank im Arbeitsspeicher anlegen und Verbindung erstellen, echo=FALSE}
t1db<-dbConnect(RSQLite::SQLite(), dbname = ":memory:")
```

Egal mit welcher Software, Sie sollten nun eine leere Datenbank geöffnet haben.

# SQL Grundlagen

Im folgenden Abschnitt wird eine Tabelle erstellt und Daten in diese eingetragen, abgefragt als auch modifiziert.

## Tabelle erstellen

Mit den folgenden Befehlen wird die Tabelle tbl_features ggf. gelöscht, also rigoros aufgeräumt, und dann erstellt.  

```{sql Tabelle tbl_features ggf. löschen, connection=t1db, include=FALSE}
DROP TABLE IF EXISTS tbl_features;
```
```{sql Tabelle tbl_features erstellen, connection=t1db, include=FALSE}
CREATE TABLE "tbl_features" (
	"feature_id"	INTEGER PRIMARY KEY,
	"feature_nr"	INTEGER NOT NULL,
	"f_name"	TEXT,
	"f_type"	TEXT,
	"f_dating"	TEXT,
	"discoverdate"	TEXT
);
```

Die englisches Befehle und Parameter müssen wohl nicht erläutert werden. Jede Anweisung kann zur besseren Lesbarkeit über mehrere Zeilen laufen und wird mit einem ";" beendet. Die Großbuchstaben sind die traditionelle Hervorheben der Syntax und nicht notwendig. Klammern gliedern, nach allgemein gültigen Regeln die Bestandteile. Gesondert erwähnt sei: **primary key** definiert feature_id als Primärschlüssel wodurch Eindeutigkeit impliziert wird und **not null** sorgt dafür, dass eine Befundnummer vergeben werden muss.  

Folgende **Datentypen** können gesetzt werden: integer (Ganzzahl), real (reelle Zahl), text (Text) und blob (binary long objct, Binärobjekt). Gängige Datentypen in SQL sind dann noch date (Datum mit Uhrzeit) und boolean (Ja/Nein). Zudem wird oft zwischen "klein" und "groß" oder expliziter Dimension unterschieden: integer, long integer, char, varchar.  SQLite ist hier etwas anders als Sie es ggf. aus anderen Systemen schon kennen (Stichwort [type affinity](https://sqlite.org/datatype3.html#type_affinity)). Das Thema ist hier jetzt nicht weiter relevant.

## Daten eintragen

Datenbanken sollten schon bei der Erhebung der Daten durch entsprechende Strukturen, z.B. durch übersichtliche und aufgabenorientierte Formulare, die Qualität der Daten gewährleisten. Die nachfolgende Syntax ist a priori nicht für die Handarbeit gedacht.

```{sql Befunddaten schreiben, connection=t1db}
INSERT INTO tbl_features (feature_nr, f_name, f_type, f_dating, discoverdate)
VALUES
(1001, 1001, 'posthole', 'not dated', '2019-05-22'),
(1002, 1002, 'pit', 'neolithic', '2019-05-22'),
(1001, 1001, 'grave', 'Corded Ware', '2019-05-22')
;
```

Die vorangehende Syntax nenn erst die Tabelle und die zu belegenden Felder, danach folgen eingeleitet durch *values* die Daten. Alle Werte werden duch "," getrennt, Text muss mit Anführungszeichen (" oder ') versehen werden und die Werte einer Datenzeile (*record*) stehen jeweils in Klammern. Beachten Sie bitte, die Anzahl und Reihenfolge der Felder und nachfolgend aufgeführten Werte müssen sich entsprechen.    

## Daten abfragen

*SELECT* ist eine der wichtigsten Anweisungen und es kann alles abgefragt werden was existiert. Wie zuvor erwähnt steht Text in Anführungszeichen, beachten Sie also das Ergebnis der folgenden Abfrage.

```{sql select statement, connection=t1db}
SELECT 'col 1', 2, '3', 1+3, pi() AS magic;
```

Die zuvor in der tabelle tbl_features eigetragenen Daten können wir nun durch anfügen des Tabellennames als  Quelle abfragen wobei wir statt einzelner Felder mit * schlicht alle abfragen.

```{sql Einfache Abfrage aller Befunddaten, connection=t1db}
SELECT * FROM tbl_features;
```

Natürlich gibt es zahlreiche Möglichkeiten die Abfrage anzupassen, um die  gewünschte Information zu erhalten. Das ist vor allem die Bedingung mit *where*. Für Zahlen können folgende Operatoren verwendet werden: <, >, = , >=, <=, <>. 

```{sql Abfrage für Zahlenfelder, connection=t1db}
SELECT feature_nr, f_type, f_dating FROM tbl_features
WHERE feature_nr <> 1002;
```

Text muss weiterhin in Anführungszeichen stehen und als Operatoren werden erneut  = und <> verwendet, dazu *like* für unscharfe Suchen in Ergänzung mit % innerhalb der Anführungszeichen und *is not* für die Negation eines Operators. Mit Klammern, *and* und *or* können komplexere Bedingungen erstellt werden. Beachten Sie bitte später auch Unterschiede zwischen *NULL* und "" als Hinweis auf eine leere Zeichenkette. 

```{sql Unscharfe Abfrage für Textfelder, connection=t1db}
SELECT feature_nr, f_type, f_dating FROM tbl_features
WHERE (f_type is not null) and (f_dating not like "n%");
```

Die Rückgabe einer Abfrage, gefiltert oder nicht, kann sortiert. Mehrere Sortierfelder werden durch "," getrennt und durch *desc* oder *asc* zwischen absteigend und aufsteigend getrennt.  

```{sql Sortierte Abfrage, connection=t1db}
SELECT feature_nr, f_type, f_dating FROM tbl_features
ORDER BY feature_nr DESC, f_dating ASC;
```

Es gibt deutlich mehr Bedingungen und Optionen in [SELECT-Abfrage](https://sqlite.org/lang_select.html) aber es reicht für den Anfang.

